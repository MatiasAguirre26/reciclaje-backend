{
  ".env": "DATABASE_URL=\"postgresql://recycle_owner:9dlIDE4kSsLt@ep-silent-sky-a5581y7n-pooler.us-east-2.aws.neon.tech/recycle?sslmode=require\"\nJWT_SECRET=tu_secreto_jwt\nPORT=3002",
  "controllers": {
    "adminController.js": "",
    "authController.js": "import { PrismaClient } from \"@prisma/client\";\nimport { hashPassword, comparePassword } from \"../utils/bcrypt.js\";\nimport { generateToken } from \"../utils/tokenManagement.js\";\nimport HTTP_STATUS from \"../helpers/httpStatus.js\";\n\nconst prisma = new PrismaClient();\n// Registro de usuario\nexport const register = async (req, res) => {\n  console.log('Método de la solicitud:', req.method);\n  console.log('Datos recibidos:', req.body);\n  const { name, username, email, password, confirmPassword } = req.body;\n\n  if (password !== confirmPassword) {\n    return res\n      .status(HTTP_STATUS.BAD_REQUEST)\n      .json({ message: \"Las contraseñas no coinciden\" });\n  }\n\n  try {\n    const userExists = await prisma.user.findUnique({ where: { email } });\n\n    if (userExists) {\n      return res\n        .status(HTTP_STATUS.BAD_REQUEST)\n        .json({ message: \"Se registrado exitosamente\" });\n    }\n\n    const hashedPassword = await hashPassword(password);\n\n    const newUser = await prisma.user.create({\n      data: {\n        name,\n        username,\n        email,\n        password: hashedPassword,\n        role: \"user\",\n      },\n    });\n    console.log('Nuevo usuario creado:', newUser); \n    return res\n      .status(HTTP_STATUS.CREATED)\n      .json({ message: \"Usuario registrado exitosamente\", user: newUser });\n  } catch (error) {\n    console.log(error)\n    return res\n      .status(HTTP_STATUS.INTERNAL_SERVER_ERROR)\n      .json({ message: \"Error al registrar usuario\", error });\n  }\n};\n\n// Login de usuario\nexport const login = async (req, res) => {\n  const { email, password } = req.body;\n\n  try {\n    const user = await prisma.user.findUnique({ where: { email } });\n\n    if (!user) {\n      return res\n        .status(HTTP_STATUS.UNAUTHORIZED)\n        .json({ message: \"Credenciales incorrectas\" });\n    }\n\n    const validPassword = await comparePassword(password, user.password);\n    if (!validPassword) {\n      return res\n        .status(HTTP_STATUS.UNAUTHORIZED)\n        .json({ message: \"Credenciales incorrectas\" });\n    }\n\n    const token = generateToken(user);\n\n    return res\n      .status(HTTP_STATUS.OK)\n      .json({ message: \"tokens generado\", token, userId:user.id, role:user.role });\n  } catch (error) {\n    return res\n      .status(HTTP_STATUS.INTERNAL_SERVER_ERROR)\n      .json({ message: \"Error al iniciar sesión\", error: error.message });\n  }\n};\n"
  },
  "helpers": {
    "httpStatus.js": "const HTTP_STATUS = {\n    OK: 200,\n    CREATED: 201,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    UNPROCESSABLE_ENTITY: 422,\n    NOT_FOUND: 404,\n    INTERNAL_SERVER_ERROR: 500\n  }\n  \n  export default HTTP_STATUS\n  "
  },
  "index.js": "import express from 'express'\nimport cors from 'cors';\nimport dotenv from 'dotenv';\nimport errorMiddleware  from './middleware/errorMiddleware.js';\nimport  authRoutes  from './routes/authRoutes.js';\nimport recyclingRoutes from './routes/recyclingRoutes.js';\nimport { confirmRecycling } from './controllers/recyclingController.js';\nimport couponRoutes  from './routes/couponRoutes.js';\nimport adminRoutes from './routes/adminRoutes.js';\n\n\ndotenv.config()\nconst app = express();\n\napp.use(cors())\n\n\napp.use(cors({\n    origin: '*',\n    methods: 'GET, POST, PUT, DELETE'\n}))\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n//endpoint de reciclaje confirmacion \napp.use('/api', recyclingRoutes)\n//  endpoints auth\n// endpoints auth\napp.use('/api/auth', authRoutes)\n\n// endpoints coupon//reward\napp.use('/api/coupons', couponRoutes)\n\n//endpoint admin\n\n\n\napp.use(errorMiddleware)\n\nconst PORT = process.env.PORT || 3002;\n\napp.listen(PORT, () => {\n    console.log(`Server running on port ${PORT}`);\n});\n\n",
  "middleware": {
    "authMiddleware.js": "import { verifyToken } from '../utils/tokenManagement.js';\nimport HTTP_STATUS from '../helpers/httpStatus.js';\n\nconst userMiddleware = (req, res, next) => {\n  const token = req.header('Authorization')?.replace('Bearer ', '');\n  \n  if (!token) {\n    return res.status(HTTP_STATUS.UNAUTHORIZED).json({ message: 'Token no proporcionado' });\n  }\n\n  const decoded = verifyToken(token);\n  if (!decoded) {\n    return res.status(HTTP_STATUS.UNAUTHORIZED).json({ message: 'Token inválido' });\n  }\n\n  req.user = decoded;\n  next();\n};\n\nexport default userMiddleware;\n",
    "errorMiddleware.js": "import { verifyToken } from \"../utils/tokenManagement.js\";\nimport HTTP_STATUS from \"../helpers/httpStatus.js\";\n\nconst userMiddleware = (req, res, next) => {\n  const token = req.header(\"Authorization\")?.replace(\"Bearer \", \"\");\n\n  if (!token) {\n    return res\n      .status(HTTP_STATUS.UNAUTHORIZED)\n      .json({ message: \"Token no proporcionado\" });\n  }\n\n  const decoded = verifyToken(token);\n  if (!decoded) {\n    return res\n      .status(HTTP_STATUS.UNAUTHORIZED)\n      .json({ message: \"Token inválido\" });\n  }\n\n  req.user = decoded;\n  next();\n};\n\nexport default userMiddleware;\n"
  },
  "package.json": "{\n  \"name\": \"reciclaje-backend\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"type\": \"module\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"seed\": \"node prisma/seed.js\",\n    \"start\": \"node index.js\",\n    \"dev\": \"node --watch index.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"@faker-js/faker\": \"^9.0.1\",\n    \"@prisma/client\": \"^5.19.1\",\n    \"bcrypt\": \"^5.1.1\",\n    \"cors\": \"^2.8.5\",\n    \"dotenv\": \"^16.4.5\",\n    \"express\": \"^4.19.2\",\n    \"express-jwt\": \"^8.4.1\",\n    \"joi\": \"^17.13.3\",\n    \"jsonwebtoken\": \"^9.0.2\"\n  },\n  \"devDependencies\": {\n    \"prisma\": \"5.19.1\"\n  }\n}\n",
  "prisma": {
    "schema.prisma": "\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\n\nmodel Benefits {\n  id                 Int  @id @default(autoincrement())\n  discountPercentage Float\n  locals             String\n  coupons            Coupon[]\n\n  @@map(\"benefits\")\n}\n\n\n// Modelo de cupones\nmodel Coupon {\n  id             Int   @id @default(autoincrement())\n  userId         Int?\n  benefitsId     Int?\n  code           String   @unique\n  discountValue  Float\n  expirationDate DateTime\n  user           User?    @relation(fields: [userId], references: [id])\n  benefits       Benefits? @relation(fields: [benefitsId], references: [id])\n  @@map(\"coupon\")\n}\n\n\n// Modelo de materiales\nmodel Material {\n  id          Int  @id @default(autoincrement())\n  name        String\n  pointsPerKg Int\n  details     TransactionDetail[]\n  @@map(\"material\")\n}\n\n// Modelo de puntos de reciclaje\nmodel RecyclingPoint {\n  id          Int  @id @default(autoincrement())\n  name        String?\n  address     String?\n  contact     String?\n  openingHours String?\n  transactions Transaction[]\n\n  @@map(\"recycling_point\")\n}\n\n// Modelo de transacciones\nmodel Transaction {\n  id                Int  @id @default(autoincrement())\n  userId            Int\n  recyclingPointId  Int?\n  adminId           Int?\n  transactionDate   DateTime? @default(now())\n  totalPoints       Int?\n  user              User?    @relation(\"UserTransactions\", fields: [userId], references: [id])\n  admin             User?    @relation(\"AdminTransactions\", fields: [adminId], references: [id])\n  recyclingPoint    RecyclingPoint? @relation(fields: [recyclingPointId], references: [id])\n  state             Boolean?\n  details           TransactionDetail[]\n  @@map(\"transaction\")\n}\n\n// Modelo de detalles de transacciones\nmodel TransactionDetail {\n  id            Int  @id @default(autoincrement())\n  transactionId Int?\n  materialId    Int?\n  weight        Float?\n  points        Int?\n  transaction   Transaction? @relation(fields: [transactionId], references: [id])\n  material      Material?    @relation(fields: [materialId], references: [id])\n  @@map(\"transaction_detail\")\n}\n\n// Modelo de usuarios\nmodel User {\n  id          Int  @id @default(autoincrement())\n  name        String\n  username    String   @unique\n  email       String   @unique\n  password    String\n  role        String\n  points      Int      @default(0)\n  coupons     Coupon[]\n  transactions Transaction[] @relation(\"UserTransactions\")\n  adminTransactions Transaction[] @relation(\"AdminTransactions\")\n  @@map(\"users\")\n}\n\n"
  },
  "routes": {
    "adminRoutes.js": "",
    "authRoutes.js": "import express from 'express';\nimport { login, register } from '../controllers/authController.js';\nimport { validateRegister } from '../middleware/registerValidationMiddleware.js';\n\nconst router = express.Router();\n\nrouter.post('/register', validateRegister, register);\nrouter.post('/login', login);\n\n\n\nexport default router;\n\n"
  },
  "utils": {
    "tokenManagement.js": "import jwt from \"jsonwebtoken\";\n\nexport const generateToken = (user) => {\n  // Convertir BigInt a string\n  const userId = user.id.toString();\n  return jwt.sign({ id: userId, role: user.role }, process.env.JWT_SECRET, {\n    expiresIn: \"1h\",\n  });\n};\n\nexport const verifyToken = (token) => {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET);\n  } catch (error) {\n    return null;\n  }\n};\n"
  }
}